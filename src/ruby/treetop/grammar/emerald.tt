#!/usr/bin/env ruby

#
# Context free grammar for the Emerald language.
# Emerald: a preprocessor for html5.
#
grammar Emerald
  include Tokens

  rule main
    (nested / line / newline)* <Node> {
      def to_html
        puts "ROOT"
        elements.each do |e|
          if e.is_a?(Node)
            e.to_html()
          else
            puts e.text_value
          end
        end
      end
    }
  end

  # A nested statement is a tag statement followed by a newline and an
  # indentation
  rule nested
    tag_statement newline (indent_line / indent_nested)+ <Node> {
      def to_html
        puts "NESTED"
        elements.each do |e|
          if e.is_a?(Node)
            e.to_html()
          else
            if e.empty?
            else
              puts "." + e.text_value + "."
              puts e.elements
              # MAKE THIS RECURSIVE!!!
              e.elements.each do |j|
                if j.is_a?(Node)
                  j.to_html()
                else
                  puts j.text_value
                end
              end
            end
          end
        end
      end
    }
  end

  rule indent_line
    indent+ line <Node> {
      def to_html
        puts "INDENT LINE"

      end
    }
  end

  rule indent_nested
    indent+ nested <Node> {
      def to_html
        puts "INDENT NESTED"
      end
    }
  end

  # Comment has optional newline, so it's not included in the first sequence
  rule line
    (text / list / tag_statement / comment) newline? <Node> {
      def to_html
        puts "LINE"
        elements.each do |e|
          if e.is_a?(Node)
            e.to_html()
          end
        end
      end
    }
  end

  # Rule for keyword list (metas, scripts, styles)
  rule list
    keyword (newline indent+ (attr space* string comma? space*)+ )* <Node>
  end

  # Single line and multiline comments
  rule comment
    space* '!' ( !"\n" . )* "\n"? <Node> / '<!' ( !"!>" . )* "!>" <Node>
  end

  # TODO: add escape characters
  rule string
    '"' ( !'"' . )* '"' <Node>
  end

  # Ex. h1 "test this out."
  rule text
    h_num space* (string / (newline indent string)*)
  end

  # Indentation rule
  rule indent
    space space <Node> {
      def to_html
        puts "INDENT"
      end
    }
  end

  # tag space* string (0 or 1), attr_list (0 or 1)
  rule tag_statement
    tag space* string? space* attr_list? <Node> {
      def to_html
        puts "TAG STATEMENT"
        elements.each do |e|
          if e.is_a?(Node)
            e.to_html()
          end
        end
      end
    }
  end

  # attribute list for
  # lparen newline (or none), attribute* rparen
  rule attr_list
    lparen newline attribute* space* rparen <Node>
  end

  # if newline option, must indent
  rule attribute
    space* attr space+ string newline <Node>
  end
end
